package de.sgrad.yamahathreditor;

import java.util.Random;

import android.os.Handler;

public class Simulator implements Runnable {
	 
    private int result = 0;
    private boolean pause = false;
    public Handler handler;
    MainActivity activity;
    int min = 0;
    int max = 0;
    SysExCommands sysExCommands;
    Automation simulation;
    public int value;
    
	byte [] dump1 = new byte [] {
	  (byte)0xF0, 0x43, 0x7D, 0x00, 0x02, 0x0C, 0x44, 0x54, 0x41, 0x31, 0x41, 0x6C, 0x6C, 0x50, 0x00, 0x00, 0x7F, 0x7F,
			0x43, 0x75, 0x73, 0x74, 0x6F, 0x6D, 0x20, 0x43, 0x6C, 0x61, 0x73, 0x73, 0x2D, 0x41, 0x20, 0x43, 0x6F, 0x6D,
			0x62, 0x6F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x01, 0x5F, 0x2C, 0x56, 0x4B, 0x3C, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x32, 0x32, 0x3D, 0x26, 0x01, 0x00, 0x02, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x35,
			0x1D, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x1E, 0x46, 0x2E,
			0x5D, 0x60, 0x00, 0x15, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x02, 0x00, 0x1F, 0x00, 0x01, 0x02,
			0x52, 0x17, 0x2F, 0x04, 0x09, 0x49, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x67, (byte)0xF7};
	
	byte [] dumpPlex = new byte [] {
			  (byte)0xF0, 0x43, 0x7D, 0x00, 0x02, 0x0C, 0x44, 0x54, 0x41, 0x31, 0x41, 0x6C, 0x6C, 0x50, 0x00, 0x00, 0x7F, 0x7F,	
					0x70, 0x6C, 0x65, 0x78, 0x65, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
					0x00, 0x00, 0x02, 0x3F, 0x57, 0x46, 0x3C, 0x50, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
					0x00, 0x32, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x02, 0x3E, 
					0x3F, 0x28, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1E, 0x46, 0x2E, 
					0x5D, 0x60, 0x00, 0x15, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x1B, 0x00, 0x00, 0x00, 
					0x5F, 0x15, 0x70, 0x08, 0x0E, 0x4C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
					0x00, 0x00, 0x00, 0x00, 0x30,(byte)0xF7 };	
	
	byte [] revLevel = new byte [] {(byte)0xf0, 0x43, 0x7d, 0x10, 0x41, 0x30, 0x01, 0x4b, 0x00, 0x00, (byte)0xf7}; // reverb level
	byte [] revType = new byte [] {(byte)0xf0, 0x43, 0x7d, 0x10, 0x41, 0x30, 0x01, 0x40, 0x00, 0x00, (byte)0xf7}; // reverb level
	byte [] revOnOff = new byte [] {(byte)0xf0, 0x43, 0x7d, 0x10, 0x41, 0x30, 0x01, 0x4f, 0x00, 0x00, (byte)0xf7}; // reverb level
	byte [] unknown = new byte [] {(byte)0xf0, 0x43, 0x7d, 0x20, 0x44, 0x54, 0x41, 0x31, 0x41, 0x6c, 0x6c, 0x50, (byte)0xf7}; // reverb level
    
    Simulator(Handler handler, MainActivity activity, Automation simulation){
    	this.handler = handler;
    	this.activity = activity;
    	sysExCommands = new SysExCommands();
    	this.simulation = simulation;
    }	

    @Override
	public void run() {
		pause = false;
		while (true) {
			if (pause) {
				try {
					Thread.sleep(500);
				} catch (InterruptedException e) {
				}

				continue;
			}
			handler.post(new Runnable() {
				@Override
				public void run() {
					if(value < max){
						value += 1;
						activity.onDataChangeUI(sysExCommands.getReverbValuesSysEx(ReverbData.reverbTypeRoomPlateHall, value,"Level"));
						activity.getReverbData().setLevel((byte)value);
						simulation.rangeSeekBar1Text.setText(String.valueOf(value));
						if(activity.reverb.initialized)
							activity.reverb.updateUI();
					}
					/*
					if(revLevel[9] < 0x64){
						revLevel[9] = (byte) (revLevel[9] + 1);
						if(revLevel[9] % 10 == 0){
							if(revLevel[9] % 15 == 0){
								activity.sysExParser.read(dumpPlex);
							}else{
								activity.sysExParser.read(dump1);
							}
						}else{
							activity.sysExParser.read(revLevel);
							revType[9] = randInt((byte)1, (byte)4);
							activity.sysExParser.read(revType);
						}
					}else{
						dump1[9] = 0x00;
						activity.sysExParser.read(unknown);
					}
					*/
				}
			});
			try {
				Thread.sleep(500);
			} catch (InterruptedException e) {
			}
		}
	}

    public void setPause(boolean pause) {
        this.pause = pause;
    }

    public boolean isPause() {
        return pause;
    }
    
    public void setRange(int min, int max){
    	this.min = min;
    	this.max = max;
    	value = min;
    }

    public void reset() {
        this.result = 0;
        handler.post(new Runnable() {
            @Override
            public void run() {
               //  tvStatus.setText("" + result);
            }
        });
    }
    
    /**
     * Returns a psuedo-random number between min and max, inclusive.
     * The difference between min and max can be at most
     * <code>Integer.MAX_VALUE - 1</code>.
     *
     * @param min Minimim value
     * @param max Maximim value.  Must be greater than min.
     * @return Integer between min and max, inclusive.
     * @see java.util.Random#nextInt(int)
     */
    public static byte randInt(byte min, byte max) {

        // Usually this can be a field rather than a method variable
        Random rand = new Random();

        // nextInt is normally exclusive of the top value,
        // so add 1 to make it inclusive
        byte randomNum = (byte) (rand.nextInt((max - min) + 1) + min);

        return randomNum;
    }
}

